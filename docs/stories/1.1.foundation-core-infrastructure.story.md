# Story 1.1: Foundation & Core Infrastructure

## Status
Draft

## Story
**As a** developer implementing the LOs Generation Pipeline,
**I want** complete project foundation with database schemas, core services, API framework, and essential infrastructure,
**so that** I can build the RAG pipeline and LO generation functionality on a solid, production-ready foundation.

## Acceptance Criteria
1. Project repository initialized with proper Python structure (src/, tests/, configs/, docs/) and dependency management
2. PostgreSQL database schemas implemented for learning_objectives, chunks, textbooks, topics, bloom_levels
3. Core services architecture created: LLM service (Gemini), Vector service (Qdrant), Processing service, Generation service
4. FastAPI framework configured with basic health-check endpoint (/health) and middleware setup
5. Essential infrastructure services configured: PostgreSQL, Qdrant, Redis via Docker Compose
6. Configuration management system with YAML configs for models, prompts, database connections
7. Basic logging infrastructure and code quality tools (black, flake8, mypy) with pre-commit hooks
8. Integration tests validate service connectivity and database operations

## Tasks / Subtasks
- [ ] Initialize project foundation (AC: 1)
  - [ ] Create project directory structure (src/, tests/, configs/, docs/)
  - [ ] Setup Poetry for dependency management with pyproject.toml
  - [ ] Configure Git repository with comprehensive .gitignore
  - [ ] Setup code quality tools (black, flake8, mypy) and pre-commit hooks
  - [ ] Create basic logging configuration with structured output

- [ ] Implement database schemas (AC: 2)
  - [ ] Design PostgreSQL schema for learning_objectives table
  - [ ] Design chunks table with chunk_id (hash-based) and metadata
  - [ ] Design textbooks, topics, and bloom_levels tables
  - [ ] Create database migration scripts using Alembic
  - [ ] Implement database connection and session management

- [ ] Build core services architecture (AC: 3)
  - [ ] Create `/src/services/` directory structure with base service class
  - [ ] Implement LLM service with Gemini 2.5 Pro/Flash API integration
  - [ ] Implement Vector service with Qdrant client and health checks
  - [ ] Implement Processing service for content ingestion and chunking
  - [ ] Implement Generation service for LO creation with quality scoring
  - [ ] Add dependency injection pattern and service configuration loading

- [ ] Setup FastAPI framework (AC: 4)
  - [ ] Initialize FastAPI application with basic configuration
  - [ ] Implement /health endpoint with service connectivity checks
  - [ ] Configure middleware for logging and error handling
  - [ ] Setup basic API documentation with OpenAPI/Swagger
  - [ ] Add request/response models using Pydantic

- [ ] Configure essential infrastructure (AC: 5)
  - [ ] Create Docker Compose configuration for local development
  - [ ] Configure PostgreSQL container with proper volumes
  - [ ] Configure Qdrant container for vector storage
  - [ ] Configure Redis container for Celery background processing
  - [ ] Setup environment variable management with .env support

- [ ] Implement configuration management (AC: 6)
  - [ ] Design YAML configuration schema for models and prompts
  - [ ] Create configuration loading with environment variable override
  - [ ] Implement database connection configuration
  - [ ] Add API settings and service endpoint configurations
  - [ ] Create configuration validation and error handling

- [ ] Setup logging and quality tools (AC: 7)
  - [ ] Configure structured logging with JSON output for production
  - [ ] Setup log rotation and configurable levels
  - [ ] Configure black for consistent code formatting
  - [ ] Setup flake8 for linting with project-specific rules
  - [ ] Configure mypy for type checking
  - [ ] Install and configure pre-commit hooks

- [ ] Create integration tests (AC: 8)
  - [ ] Test database connection and basic CRUD operations
  - [ ] Test Qdrant service connectivity and basic operations
  - [ ] Test Gemini API service connectivity and basic calls
  - [ ] Test /health endpoint responses and service status checks
  - [ ] Test configuration loading and validation

## Dev Notes

### Previous Story Insights
This is the foundation story - no previous story context available.

### Data Models
**Database Schema (Source: requirements.md):**
- **learning_objectives table**: Store generated LOs with Bloom's taxonomy, topic mapping, source traceability
- **chunks table**: Store processed content chunks with unique chunk_id (hash-based), metadata
- **textbooks table**: Track source materials and versioning
- **topics table**: TBAT Physics blueprint topic mapping
- **bloom_levels table**: Bloom's taxonomy classification levels
- **Relationships**: Normalized schema supporting multi-exam expansion capability

### API Specifications
**FastAPI Endpoints (Source: requirements.md FR15):**
- **/health**: Service connectivity and status checks
- **Future endpoints**: /generate-los, /status/{job_id} (implemented in later stories)
- **Documentation**: OpenAPI/Swagger integration for testing and integration
- **Response format**: JSON with proper HTTP status codes

### Component Specifications
**Core Services Architecture (Source: technical-assumptions.md):**
- **LLM Service**: Gemini 2.5 Pro (complex tasks) and Flash (lighter operations) integration
- **Vector Service**: Qdrant client for vector storage and similarity search
- **Processing Service**: Content ingestion, PyMuPDF text extraction, basic chunking
- **Generation Service**: LO creation with quality scoring and validation
- **Base Service**: Abstract base class with dependency injection pattern

### File Locations
**Project Structure (Source: technical-assumptions.md - Monorepo):**
- `/src/services/`: All service classes and business logic
- `/src/models/`: Database models and Pydantic schemas  
- `/src/api/`: FastAPI application and endpoints
- `/configs/`: YAML configuration files
- `/tests/`: Unit and integration tests mirroring src/ structure
- `/docker-compose.yml`: Local development infrastructure

### Testing Requirements
**Testing Strategy (Source: requirements.md NFR13-NFR18):**
- **Unit Tests**: Minimum 60% code coverage for MVP
- **Integration Tests**: End-to-end pipeline validation (ingestion → retrieval → generation)
- **API Tests**: Success cases and primary error scenarios
- **Database Tests**: Transaction testing ensuring data consistency
- **Framework**: pytest with fixtures, pytest-cov, pytest-asyncio

### Technical Constraints
**Infrastructure Requirements (Source: technical-assumptions.md):**
- **Local Development**: Docker Compose for PostgreSQL, Qdrant, Redis
- **Language Support**: English-first with basic Thai support (bge-m3 embeddings)
- **Architecture**: Monolith with async processing via Celery workers
- **Configuration**: Version-controlled YAML configs with Git
- **Quality Tools**: black + flake8 + mypy pipeline for code standards

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-28 | v1.0 | Consolidated foundation story from Epic 1 requirements | Sarah (PO) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*Results from QA Agent review will appear here after implementation*